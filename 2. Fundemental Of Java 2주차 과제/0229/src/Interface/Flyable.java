package src.Interface;
/*
 * 1. Flyable 인터페이스의 주요 메서드는 fly()여야 한다고 생각한다.
 * => 그렇지 않으면, 
 * 
 * 2. 그러나 날 수 있다면 -> 날 수 있는 유닛을 때릴 수 있다.
 * 3. 그리고 날 수 있다면 -> 날 수 없는 유닛도 때릴 수 있다.
 * 4. *그리고 날 수 있다면 -> 날 수 있거나, 나는 것을 때릴 수 있는 유닛만 나를 때릴 수 있다.
 * => "날 수 있다"는 것을 인터페이스로 제대로 구현하려면 fly() 메서드를 구현하는 게 맞다.
 * => 그러나, 파라미터로 넘겼을 때, "나를 때릴 수 있는가"를 명확하게 구분하는 게 좋다고 생각했다.
 * 
 * boolean fly = true; 이렇게 하면 Unit으로 멤버 변수 가져와도 된다고 생각한다.
 * 근데, 다형성을 이용하지 못하기 때문에 객체지향적이지 못한 설계라고 생각한다.
 * 또한, (날 수 없는 유닛 != 날 수 없는 유닛)은 항상 true이다.
 * 따라서, 나는 이 인터페이스를 쓰는 게, '그룹화' 관점에서 맞다고 생각한다.
 * 그리고, '기능'관점에서 봤을 때는 '때리는 것'과 연관짓고, 그 외의 것들은 연관지으면 안 된다고 생각한다.
 * 
 * 근데 이러려면 게터 세터를 또 구현해 줘야 한다.
 * Flyable에 Flyable 타입의 게터랑 세터를 구현해라? 이건 좀 아니라고 생각한다.
 * 좀 더 멀리 나아가서, 나는 이 상황에서 인터페이스가 왜 필요한지 모르겠다.
 * 
 * 난 인터페이스는 그룹화하는 데에만 사용하련다... 더 이상 생각은 안 한다.
 * 인터페이스는 그룹화하는 것 만으로도 의미가 있지 않을까 생각해 본다...
 * 
 * 메서드의 이름은 고의적으로 다르게 했다.
 * 'attack()'으로 같게 하면 오버로딩도 하고 좋겠다고 생각은 했다.
 * 하지만, attack(Unit unit)과 attack(Flyable flyable) 메서드가 있는 상태에서
 * attack(new Dragon)처럼 둘 다 구현하고 상속하는 객체가 나와버리면, 컴파일 에러를 발생시킨단다.
 * C++은 그냥 넘어갔던 것 같은데,, 아마 Java가 다중 상속을 지원하지 않는 하나의 이유라고 생각한다.
 */

public interface Flyable extends FlyAttackable { // 다 때릴 수 있다.
    
}